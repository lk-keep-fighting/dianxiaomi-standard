#!/usr/bin/env python3
"""Package the automation system into a self-contained Windows executable.

This helper wraps ``pyinstaller`` with sensible defaults for the project and
injects sensitive configuration (for example Supabase credentials) directly into
``src/_embedded_env.py`` so that the generated executable can run without any
manual environment setup.
"""
from __future__ import annotations

import argparse
import json
import os
import platform
import shutil
import subprocess
import sys
from datetime import datetime
from pathlib import Path
from typing import Dict, Iterable, List, Optional, Tuple

PROJECT_ROOT = Path(__file__).resolve().parents[1]
SRC_DIR = PROJECT_ROOT / "src"
EMBEDDED_ENV_PATH = SRC_DIR / "_embedded_env.py"
DEFAULT_APP_NAME = "digital-chief"


def parse_dotenv(path: Path) -> Dict[str, str]:
    """Parse a minimal ``.env`` style file into a dictionary."""

    result: Dict[str, str] = {}
    if not path.exists():
        raise FileNotFoundError(f"Environment file not found: {path}")

    for raw_line in path.read_text(encoding="utf-8").splitlines():
        line = raw_line.strip()
        if not line or line.startswith("#"):
            continue
        if "=" not in line:
            continue
        key, value = line.split("=", 1)
        key = key.strip()
        value = value.strip().strip("'\"")
        result[key] = value
    return result


def parse_inline_pairs(pairs: Iterable[str]) -> Dict[str, str]:
    """Parse ``KEY=VALUE`` command-line overrides."""

    result: Dict[str, str] = {}
    for item in pairs:
        if "=" not in item:
            raise ValueError(f"Inline override must be in KEY=VALUE format (got: {item})")
        key, value = item.split("=", 1)
        result[key.strip()] = value.strip()
    return result


def ensure_pyinstaller_available() -> str:
    """Return the path to the ``pyinstaller`` executable if it exists."""

    candidate = shutil.which("pyinstaller")
    if candidate:
        return candidate
    raise RuntimeError(
        "PyInstaller æœªå®‰è£…ã€‚è¯·å…ˆè¿è¡Œ `pip install -r requirements-packaging.txt` å†ç»§ç»­ã€‚"
    )


def resolve_add_data_args() -> List[str]:
    """Build the ``--add-data`` arguments for PyInstaller."""

    entries: List[Tuple[Path, str]] = [
        (PROJECT_ROOT / "config", "config"),
        (PROJECT_ROOT / "data", "data"),
    ]

    args: List[str] = []
    separator = ";" if os.name == "nt" else ":"
    for src, target in entries:
        if not src.exists():
            continue
        args.extend(["--add-data", f"{src}{separator}{target}"])
    return args


def format_embedded_module(values: Dict[str, str]) -> str:
    """Render the Python source for ``_embedded_env.py`` with ``values``."""

    timestamp = datetime.utcnow().isoformat(timespec="seconds") + "Z"
    payload = ",\n    ".join(
        f"{json.dumps(key)}: {json.dumps(value)}" for key, value in sorted(values.items())
    )
    return (
        '"""Embedded environment fallbacks (auto-generated)."""\n'
        "from __future__ import annotations\n\n"
        "from typing import Dict\n\n"
        f"# Generated by scripts/package_windows_exe.py on {timestamp}\n"
        "EMBEDDED_ENV: Dict[str, str] = {\n"
        f"    {payload}\n"
        "}\n"
    )


def write_embedded_env(values: Dict[str, str]) -> str:
    """Overwrite ``_embedded_env.py`` and return the previous content."""

    previous = EMBEDDED_ENV_PATH.read_text(encoding="utf-8") if EMBEDDED_ENV_PATH.exists() else ""
    EMBEDDED_ENV_PATH.write_text(format_embedded_module(values), encoding="utf-8")
    return previous


def restore_embedded_env(previous: str) -> None:
    """Restore the original ``_embedded_env.py`` contents."""

    EMBEDDED_ENV_PATH.write_text(previous, encoding="utf-8")


def build_executable(args: argparse.Namespace, env_values: Dict[str, str]) -> None:
    """Invoke PyInstaller with the collected configuration."""

    pyinstaller = ensure_pyinstaller_available()

    dist_dir = (PROJECT_ROOT / "dist" / "windows").resolve()
    build_dir = (PROJECT_ROOT / "build" / "windows").resolve()
    dist_dir.mkdir(parents=True, exist_ok=True)
    build_dir.mkdir(parents=True, exist_ok=True)

    command: List[str] = [
        pyinstaller,
        "--noconfirm",
        "--clean",
        "--onefile",
        "--name",
        args.name or DEFAULT_APP_NAME,
        "--distpath",
        str(dist_dir),
        "--workpath",
        str(build_dir),
        "--specpath",
        str(build_dir),
        "--paths",
        str(SRC_DIR),
        "--hidden-import",
        "playwright.sync_api._generated",
        "--hidden-import",
        "amazon_product_parser",
        "--hidden-import",
        "core.amazon_product_parser",
        "--hidden-import",
        "playwright_helper",
        "--hidden-import",
        "openai",
        "--hidden-import",
        "requests",
        "--hidden-import",
        "bcrypt",
        "--collect-all",
        "playwright",
        "--collect-all",
        "openai",
    ]
    command.extend(resolve_add_data_args())
    command.append(str(SRC_DIR / "main.py"))

    env = os.environ.copy()
    env.update(env_values)

    print("ğŸ› ï¸ è¿è¡Œæ‰“åŒ…å‘½ä»¤:")
    print(" ".join(command))
    subprocess.run(command, check=True, cwd=PROJECT_ROOT, env=env)


def collect_env_values(args: argparse.Namespace) -> Dict[str, str]:
    """Collect and validate environment variables to embed."""

    collected: Dict[str, str] = {}

    for env_file in args.env_file:
        collected.update(parse_dotenv(Path(env_file)))

    collected.update({key: value for key, value in os.environ.items() if key.startswith("SUPABASE_")})

    inline_overrides = parse_inline_pairs(args.set or [])
    collected.update(inline_overrides)

    if args.supabase_url:
        collected["SUPABASE_URL"] = args.supabase_url
    if args.supabase_api_key:
        collected["SUPABASE_API_KEY"] = args.supabase_api_key

    required_keys = ["SUPABASE_URL", "SUPABASE_API_KEY"]
    missing = [key for key in required_keys if not collected.get(key)]
    if missing:
        raise RuntimeError(
            "ç¼ºå°‘å¿…è¦çš„ Supabase é…ç½®: " + ", ".join(missing) +
            "ã€‚å¯ä»¥é€šè¿‡å‚æ•°æˆ– .env æ–‡ä»¶æä¾›ï¼Œä¾‹å¦‚: --supabase-url ... --supabase-api-key ..."
        )

    return collected


def main(argv: Optional[List[str]] = None) -> int:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("--supabase-url", help="Supabase é¡¹ç›®çš„ RESTful è®¿é—®åœ°å€")
    parser.add_argument("--supabase-api-key", help="Supabase æœåŠ¡å¯†é’¥")
    parser.add_argument(
        "--env-file",
        action="append",
        default=[],
        help="é™„åŠ çš„ .env æ–‡ä»¶è·¯å¾„ï¼ˆå¯å¤šæ¬¡æŒ‡å®šï¼Œåè€…è¦†ç›–å‰è€…ï¼‰",
    )
    parser.add_argument(
        "--set",
        action="append",
        default=[],
        metavar="KEY=VALUE",
        help="é¢å¤–åµŒå…¥çš„ç¯å¢ƒå˜é‡ï¼ˆå¯é‡å¤æŒ‡å®šï¼‰",
    )
    parser.add_argument(
        "--name",
        default=DEFAULT_APP_NAME,
        help="ç”Ÿæˆçš„å¯æ‰§è¡Œæ–‡ä»¶åç§°ï¼ˆé»˜è®¤: digital-chiefï¼‰",
    )
    parser.add_argument(
        "--keep-embedded",
        action="store_true",
        help="æ‰“åŒ…å®Œæˆåä¿ç•™å†™å…¥çš„ _embedded_env.pyï¼ˆé»˜è®¤ä¼šè‡ªåŠ¨è¿˜åŸï¼‰",
    )

    args = parser.parse_args(argv)

    if platform.system() != "Windows":
        print("âš ï¸ å½“å‰ç³»ç»Ÿå¹¶é Windowsã€‚ç”Ÿæˆçš„å¯æ‰§è¡Œæ–‡ä»¶ä»ç„¶ä»¥ Windows ä¸ºç›®æ ‡ï¼Œä½†å»ºè®®åœ¨ Windows ç¯å¢ƒä¸­æ‰§è¡Œæ‰“åŒ…ã€‚")

    env_values = collect_env_values(args)
    print("ğŸ” åµŒå…¥ç¯å¢ƒå˜é‡:", ", ".join(sorted(env_values.keys())))
    previous_content = write_embedded_env(env_values)

    try:
        build_executable(args, env_values)
        print("\nâœ… æ‰“åŒ…å®Œæˆï¼Œç”Ÿæˆçš„å¯æ‰§è¡Œæ–‡ä»¶ä½äº dist/windows ç›®å½•ä¸‹ã€‚")
    finally:
        if args.keep_embedded:
            print("â„¹ï¸ æŒ‰ç…§å‚æ•°è¦æ±‚ï¼Œä¿ç•™ç”Ÿæˆçš„ _embedded_env.py æ–‡ä»¶ã€‚")
        else:
            restore_embedded_env(previous_content)

    return 0


if __name__ == "__main__":  # pragma: no cover - script entry point
    sys.exit(main())
